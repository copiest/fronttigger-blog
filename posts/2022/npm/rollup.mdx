---
title: npm workspaces와 rollup으로 모노레포 구성하기 #required
tags:
  - npm
  - monorepo
  - react
  - rollup
published: true # required
date: '2022. 3. 1' # required
description: '모노레포에 rollup 끼얹기' # required
thumbnailImg: '/thumbnail/2022/03/monorepo/npm-rollup.png' # required
---

## 모노레포는 갑자기 왜?

회사에서 이번에 새롭게 대개편 작업을 하면서 정말 많은 도메인의 개편을 하였다.

REST API를 Apollo GraphQL로 바꾸고, 기존 서비스 되고있던 화면들도 많은 개편이 있었으며 거기에 대한 많은 컴포넌트들과 유틸들도 생겨났다.

현재 서비스 중인 프로젝트는 하나의 형태로 되어있는 **모노리스**로 구성되어있는데, 몇년간 이어져온 그런 코드들과 이번 새롭게 개편한 코드들이 섞여 정말 비대한 프로젝트가 만들어지고 있었다.

여기까지는 뭐 개발자도 없고 관리하기 편하니까 어쩔 수 없이 가져가는 구조라고 생각한다.

그런데 이번에 부분적으로 화면들을 개선하면서 동시에 Next.js로 개발해보자는 얘기가 나왔는데 현재 하나의 프로젝트로 되어있다보니 이를 한 번에 Next.js로 옮길 수도 없는 노릇이고, 그렇다고 부분적으로 적용해서 서비스하기에는 현재로선 기술적으로 부족하다고 판단이 되었다.

그래서 일단 먼저 공통적으로 사용되는 컴포넌트, 유틸, 커스텀 훅 등을 먼저 모아놓은 후 추후 어떤 형태의 구조를 가져가던 적어도 공통으로 사용되는 것들은 재활용 할 수 있다고 판단했고 이를 하기 위해서 공통 라이브러리를 제작하기로 결정했다.

스펙을 고민하던 중 마침 사이드 프로젝트에서 사용하던 **npm workspaces와 rollup**조합을 통해 구성하기로 결정하였고, 이를 셋업한 경험을 공유하려 한다.

만약 npm workspaces가 생소하다면 아주 기초적인 내용을 다룬 [npm workspaces로 모노레포 구성하기](https://tigger.dev/2022/npm/workspace)글을 참고하면 도움이 될 것 같다.

## 모노레포 프로젝트 구성

npm workspaces를 활용하여 모노레포의 기본 프로젝트를 구성해주었다.

여기에 기본적으로 사용될 **라이브러리, 린트, 타입스크립트** 등을 포함하였다.
구성한 프로젝트 구조는 아래와 같다.

```text
+-- .github
|   +-- workflows [CI/CD]
|   |   +-- *.yaml
+-- packages
|   +-- hooks [리액트에서 사용될 커스텀 훅]
|   |   +-- src
|   |   |   +-- index.ts
|   |   |   +-- *.ts
|   |   +-- package.json
|   |   +-- README.md
|   |   +-- rollup.config.js
|   |   +-- tsconfig.esm.json
|   |   +-- tsconfig.json
|   +-- utils [공통 유틸 모듈]
|   |   +-- src
|   |   |   +-- index.ts
|   |   |   +-- *.ts
|   |   +-- package.json
|   |   +-- README.md
|   |   +-- rollup.config.js
|   |   +-- tsconfig.esm.json
|   |   +-- tsconfig.json
+-- scripts
|   +-- *.sh
+-- .eslintrc
+-- .gitignore
+-- .prettierrc
+-- CHANGELOG.md
+-- package.json
+-- README.md
+-- tsconfig.base.json
```

최상위에 프로젝트 자체에서 사용될 규칙, 의존성, 설정을 한 후 **packages** 내부에서 이를 가져와 사용할 수 있도록 구성했다.

현재 컴포넌트에 대한 부분들은 없는데 추후 컴포넌트를 제작할 때 CSS 라이브러리, 테스트 등 정해지는 스펙에 따라 추가 셋업이 필요할 것 같다.

## Rollup

번들러의 한 종류인 Rollup은 webpack과 같이 여러 파일들을 통해 애플리케이션 혹은 라이브러리를 만들어주는 번들러다.
그 중에서 Rollup을 사용한 이유는 [Tree Shaking](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking)을 위해서인데,
webpack으로도 가능하지만 Rollup을 사용하면 ESM 형태로 바로 빌드가 가능하기 때문에 보다 쉽고 간편하게 구현할 수 있다.

### config

rollup에서 제공해주는 여러가지 기능과 플러그인들을 활용하여 설정해보았다.

```javascript
import fs from 'fs'
import path from 'path'

import babel from '@rollup/plugin-babel'
import resolve from '@rollup/plugin-node-resolve'
import commonjs from '@rollup/plugin-commonjs'
import typescript from 'rollup-plugin-typescript2'
import peerDepsExternal from 'rollup-plugin-peer-deps-external'
import terser from 'rollup-plugin-terser'

// 번들링할 파일을 객체에 담는다.
const inputs = fs.readdirSync('./src').reduce((result, file) => {
  const fileName = path.parse(file).name
  result[fileName] = `src/${file}`
  return result
}, {})

const input = { ...inputs, index: './src/index.ts' }

export default [
  {
    input,
    // 번들할 포맷과 디렉토리를 특정 파일에 명시한다.
    output: [
      {
        dir: 'lib',
        format: 'cjs',
      },
    ],
    external: [/@babel\/runtime/],
    plugins: [
      // peerDependencies에 있는 의존성들을 빌드에 포함시키지 않는다.
      peerDepsExternal(),
      // babel 설정을 할 수 있도록 도와준다.
      babel({
        babelHelpers: 'runtime',
        exclude: /node_modules/,
      }),
      // 외부 라이브러리 사용 및 ts, tsx 지원을 해준다.
      resolve(),
      // Commonjs 형태의 코드를 ES6로 변환하여 빌드에 포함되도록 해준다.
      commonjs(),
      // 타입스크립트를 사용할 수 있게 해준다.
      typescript({ useTsconfigDeclarationDir: true }),
      // 번들 결과물을 minify 해준다.
      terser(),
    ],
  },
  {
    input,
    output: [
      {
        dir: 'lib/esm',
        format: 'esm',
      },
    ],
    external: [/@babel\/runtime/],
    plugins: [
      peerDepsExternal(),
      babel({
        babelHelpers: 'runtime',
        exclude: /node_modules/,
      }),
      resolve(),
      commonjs(),
      typescript({ useTsconfigDeclarationDir: true, tsconfig: 'tsconfig.esm.json' }),
      terser(),
    ],
  },
]
```

config 설정은 ESM 형식과 CJS 형식을 지원하기 위해 두 설정을 모두 추가해주었습니다.

ESM의 경우 다른 경로에 설정하기 때문에 ts 설정도 따로 분리하여 추가해주었습니다.

### package.json
